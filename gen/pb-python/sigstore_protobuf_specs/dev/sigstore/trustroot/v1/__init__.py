# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: sigstore_trustroot.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import List

import betterproto

from ...common import v1 as __common_v1__


@dataclass(eq=False, repr=False)
class TransparencyLogInstance(betterproto.Message):
    """
    TransparencyLogInstance describes the immutable parameters from a
    transparency log. See https://www.rfc-editor.org/rfc/rfc9162.html#name-log-
    parameters for more details. The incluced parameters are the minimal set
    required to identify a log, and verify an inclusion promise.
    """

    base_url: str = betterproto.string_field(1)
    """The base URL at which can be used to URLs for the client."""

    hash_algorithm: "__common_v1__.HashAlgorithm" = betterproto.enum_field(2)
    """The hash algorithm used for the Merkle Tree."""

    public_key: "__common_v1__.PublicKey" = betterproto.message_field(3)
    """
    The public key used to verify signatures generated by the log. This
    attribute contains the signature algorithm used by the log.
    """

    log_id: "__common_v1__.LogId" = betterproto.message_field(4)
    """The unique identifier for this transparency log."""


@dataclass(eq=False, repr=False)
class CertificateAuthority(betterproto.Message):
    """
    CertificateAuthority enlists the information required to identify which CA
    to use and perform signature verification.
    """

    subject: "__common_v1__.DistinguishedName" = betterproto.message_field(1)
    """
    The root certificate MUST be self-signed, and so the subject and issuer are
    the same.
    """

    uri: str = betterproto.string_field(2)
    """The URI at which the CA can be accessed."""

    cert_chain: "__common_v1__.X509CertificateChain" = betterproto.message_field(3)
    """The certificate chain for this CA."""

    valid_for: "__common_v1__.TimeRange" = betterproto.message_field(4)
    """
    The time the *entire* chain was valid. This is at max the longest interval
    when *all* certificates in the chain were valid, but it MAY be shorter.
    """


@dataclass(eq=False, repr=False)
class TrustedRoot(betterproto.Message):
    """
    TrustedRoot describes the client's complete set of trusted entities. How
    the TrustedRoot is populated is not specified, but can be a combination of
    many sources such as TUF repositories, files on disk etc. The TrustedRoot
    is not meant to be used for any artifact verification, only to capture the
    complete/global set of trusted verification materials. When verifying an
    artifact, based on the artifact and policies, a selection of
    keys/authorities are expected to be extracted and provided to the
    verification function. This way the set of keys/authorities kan be kept to
    a minimal set by the policy to gain better control over what signatures
    that are allowed.
    """

    tlogs: List["TransparencyLogInstance"] = betterproto.message_field(1)
    """A set of trusted Rekor servers."""

    certificate_authorities: List["CertificateAuthority"] = betterproto.message_field(2)
    """
    A set of trusted certificate authorites (e.g Fulcio), and any intermediate
    certificates they provide. If a CA is issuing multiple intermediate
    certificate, each combination shall be represented as separate chain. I.e,
    a single root cert may appear in multiple chains but with different
    intermediate and/or leaf certificates. The certificates are intended to be
    used for verifying artifact signatures.
    """

    ctlogs: List["TransparencyLogInstance"] = betterproto.message_field(3)
    """A set of trusted certificate transparency logs."""

    timestamp_authorities: List["CertificateAuthority"] = betterproto.message_field(4)
    """A set of trusted timestamping authorities."""


@dataclass(eq=False, repr=False)
class TransparencyLogIdentifier(betterproto.Message):
    """
    TransparencyLogIdentifier contains information that can be used to identify
    a `TransparencyLogInstance`, either by its log id or its base_uri.
    """

    log_id: "__common_v1__.LogId" = betterproto.message_field(1, group="id")
    """The log id of the transparency log."""

    uri: str = betterproto.string_field(2, group="id")
    """The base_uri for the transparency log."""


@dataclass(eq=False, repr=False)
class CertificateAuthorityIdentifier(betterproto.Message):
    """
    CertificateAuthorityIdentifier contains information that can be used to
    identify a `CertificateAuthority`, either by its subject or by its uri.
    """

    subject: "__common_v1__.DistinguishedName" = betterproto.message_field(
        1, group="id"
    )
    """The subject of the certificate authority."""

    uri: str = betterproto.string_field(2, group="id")
    """The uri of the certificate authority."""


@dataclass(eq=False, repr=False)
class Environment(betterproto.Message):
    """
    Environment acts a selector to filter down a trust root to a smaller one. A
    policy should reference an environment, or embed one that can be used
    during artifact verification to filter the global trust root into a one
    only containing the relevant instances. An environment does not take
    temporality into account when selecting the instances from a trust root.
    Prior to performing verification the temporal aspect should be further
    examined to reduce the set of instances.
    """

    name: str = betterproto.string_field(1)
    """The name of the environment."""

    tlog: List["TransparencyLogIdentifier"] = betterproto.message_field(2)
    """Ids for artifact signature transparency log to include."""

    cas: List["CertificateAuthorityIdentifier"] = betterproto.message_field(3)
    """Ids for certificate authorities to include."""

    ctlogs: List["TransparencyLogIdentifier"] = betterproto.message_field(4)
    """Ids for certificate transparency logs to include."""

    tsas: List["CertificateAuthorityIdentifier"] = betterproto.message_field(5)
    """Ids for timestamp authorities to include."""


@dataclass(eq=False, repr=False)
class Policy(betterproto.Message):
    """
    Policy to apply to a trust root prior to creating the verification Input
    when calling a verifier. Not that the Policy does NOT contain any reference
    to a bundle. How this mapping happens is specific for each client.
    """

    name: str = betterproto.string_field(1)
    environment: "Environment" = betterproto.message_field(2)
    certificate_identities: "__common_v1__.CertificateIdentities" = (
        betterproto.message_field(3, group="signers")
    )
    public_keys: "__common_v1__.PublicKeyIdentities" = betterproto.message_field(
        4, group="signers"
    )
